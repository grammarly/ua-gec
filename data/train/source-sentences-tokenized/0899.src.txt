Скінченні автомати можуть викликати моторошні в'єтнамські флешбеки про незалік з теорії алгоритмів , від них може віяти смутком чорнобілих сторінок даташитів якихось мікрочіпів , і коли я питаю на співбесідах iOS - розробників про їх улюблені шаблони – скінченні автомати є точно не найбільш частою відповіддю .
Вони точно не можуть конкурувати в хайповості з усіляким модними паттернами світу iOS - розробки на кшталт VIPER , RIBs , Redux чи MVVM .
Однак , скінченні автомати , або Finite State Machines , – це абсолютно незаслужено забутий шаблон проектування , що робить життя iOS - розробника простішим і зрозумілішим .
Сьогодні ми з вами спробуємо поглянути на нього по-новому , і знайти у своїх проектах місце для цієї простої та універсальної абстракції .
Про скінченні автомати
Перш ніж почати , давайте домовимось називати скінченні автомати просто й по-народному : стейт - машинами .
Це не зовсім коректний переклад цього терміну , але в коридорах наших ІТ - компаній ви , найімовірніше , почуєте саме цей варіант , адже лютий англоукраїнський техносурж – це і є той правдивий варіант української , котрим спілкуються інженери за межами книжок про програмування .
Отож , почнемо .
Що таке стейт - машина ?
Це спосіб описати роботу якогось пристрою .
Уявімо собі , що в нас є холодильник .
Він працює дуже просто : якийсь час він охолоджує свою камеру , а потім якийсь час чекає , доки камера нагріється до максимально допустимої температури .
Фактично , в нього є два режими роботи : охолодження та очікування .
Ці режими ми називатимемо станами .
Холодильник переключається між своїми станами лише у випадку настання певних подій , зокрема :
температура опустилась нижче мінімуму температура піднялась вишче максимуму
Ці події змушують холодильник переходити з одного стану в інший :
<схема >
Таке зрображення роботи холодильника ми і називаємо стейт - машиною , або машиною із скінченними станами .
Будь-який пристрій , який в різний час веде себе по-різному , можна описати за допомогою стейт - машини .
Перевага цієї форми в тому , що вона є інтуїтивно зрозумілою .
Наприклад , зовсім не складно зрозуміти алгоритм роботи якоїсь програми , коли його записано так :
<схема >
Окрім того , що ця форма є зрозумілою , вона є повною .
Зі схеми вище зрозуміло , що операцію скасування ( cancel ) можна виконати тоді , коли ця програма знаходиться у стані Processing , але не можна виконати тоді , коли програма знаходиться у стані Loading .
Лише уявіть , якби ваш замовник описував вам вимоги до вашої програми , послуговуючись мовою стейт - машин , скільки би безцінних годин життя ви могли би зекономити ?
Простота і універсальність цієї форми представлення інформації ставить її в один ряд з діаграмами Венна та діаграмами Ґанта .
Мова програмування Swift дозволяє дуже просто реалізовувати стейт - машини .
Давайте спробуємо описати роботу холодильника :
<код>
Це лише один зі способів представити скінченний автомат мовою Swift , існує багато інших , часто нічим не гірших , а іноді навіть і чимось кращих за даний .
Перевагою даного запису скінченного автомата є використання вичерпності інструкції switch у Swift .
Якщо завтра нам доведеться реалізовувати новий стан , компілятор змусить нас подумати про те , як слід реагувати на кожну з існуючих подій в цьому новому стані .
Це ж саме працюватиме з новими подіями .
<код>
Те ж саме стосується й нових подій .
Коли ми додаємо якусь нову подію , компілятор змушує нас подумати : в яких станах доречно реагувати на нову подію , а в яких ні ?
<код>
Проєктуємо , використовуючи скінченні автомати
Ясна річ , скінченні автомати можна застосовувати не лише при проєктуванні холодильників .
Ми iOS інженери : ми не будуємо холодильники , ми проєктуємо інтерфейси та скролимо списки .
Давайте спробуємо втулити стейт - машину куди - небудь в якийсь код , котрий вирішував би реальну задачу .
Уявімо собі , що нам потрібно реалізувати кнопки " Shift " на мобільній клавіатурі .
Вона відрізняється від кнопок на фізичній клавіатурі тим , що фактично поєднує логіку кнопок Caps Lock та Shift в одній кнопці , тому вона має три стани : Off , On , та CapsLock .
В залежності від швидкості і кількості натискать на кнопку , її стан змінюються наступним чином :
Shift state machine
Спробувавши лаконічно пояснити , як повинна працювати кнопка , ми , власне , й побудували стейт - машину , і тепер лишилось перетворити її на код .
<код>
Реалізація стейт - машини нескладна , і не вимигає додаткових коментарів .
Користувач цієї стейт - машини повинен робити дві речі : надсилати події , та міняти UI в залежності від стану цієї стейт - машини .
Слід , утім , звернути увагу на те , чого в цьому коді немає .
Тут немає роботи з конкретними UI - елементами .
Тут взагалі немає жодних залежностей .
Логіка кнопки живе окремо , а UI – окрема .
Ми , наприклад , можемо переписати UI з UIKit на SwiftUI , при цьому логіка не зміниться .
Зручно , чи не так ?
Приклад з таблицею
Давайте розглянемо більш життєвий приклад .
Нехай ми будуємо додаток , в якому користувач може відмічати різні пам'ятки та цікаві місця , котрі він відвідав , і нам потрібно відобразити список цих пам'яток .
Та що там робити , UITableViewController чи List зі SwiftUI , 15 хвилин - і готово .
< Скріншот додатку зі списком чекінів >
Щоправда , якщо ми хочемо , щоб цим списком користувались живі люди , і щоб їм було зручно , то нам варто подумати про багато нюансів .
Наприклад , коли список порожній - користувач побачить просто білий екран .
І в нашого користувача будуть питання : де я ?
Чому екран порожній ?
Це якась помилка ?
Чи просто поки що немає данних ?
Тому , якщо ми любимо свого користувача , ми покажемо йому якесь пояснення :
Як не варто показуватии порожні списки :
Як слід показуватии порожні списки : < Скріншот додатку з неправильним порожнім списком> |< Скріншот додатку з правильним порожнім списком >
Якщо ми зберігатимемо дані користувачів на сервері , то користувач побачить свої чекіни не одразу , йому слід буде почекати , допоки не завантажаться дані .
І знову ж таки , якщо ми любимо свого користувача , ми не полінимось пояснити йому , що ж відбувається , показавши екран із завантаженням :
< Скріншот додатку з завантаженням списку >
Врешті , не всяке завантаження даних із мережі закінчується успішно , виникнення помилки в такому випадку є цілком штатною ситуацією .
Шибати UIAlertController в обличчя користувача щоразу , коли він зайшов у підземний перехід і в нього пропало інтернет - з'єднання - це насправді трохи навіть грубо , більш доречним буде вбудувати повідомлення про помилку в сам екран , турботливо поклавши до нього кнопочку " Спробуй ще " ( як колись писали під кришечками акційної Фанти ) .
< Скріншот додатку з помилкою завантаження >
Коли проектуєш модель даних для такого списку , дуже допомагає вчасне усвідомлення , що модель не повинна бути структурою , вона повинна бути перечисленням .
Дійсно , ми показуємо або список , або екран із завантаженням , або екран з помилкою , або екран з повідоменням про те , що немає даних :
<код>
Однак , такою моделлю даних потрібно якось керувати .
А ще треба якось реагувати на зміни у даній моделі , не ускладнюючи код .
Уявімо собі , що ми керуємо даною моделлю напряму у в'ю-контролері :
<код>
Як бачимо у прикладі вище , у простих випадках керувати такою моделлю нескладно , однак при збільшенні кількості елементів у перечисленні CheckinListViewData , що служить нашою моделлю , збільшується і складність нашого коду .
Уявімо собі , що ми хочемо реалізувати принцип " відкладеного логіну " , коли користувач може послуговуватись значною частиною функціональністі додатку не аутентифікувавшись , і змушений логінитись лише в момент , коли це дійсно необхідно .
В такому додатку на екран зі списоком пам'яток може потрапити неаутентифікований користувач , і це є штатною ситуацією :
< Скріншот додатку з необхідністю залогінитись >
Для реалізації такої поведінки , нам потрібно додати новий стан до нашої моделі :
<код>
Бачимо , що тепер нам потрібно міняти нашу модель у різних місцях , з різних причин , і при цьому тримати її консистентною .
Саме з цих причин у нас з'являються інструкції guard на початку методів logoutPressed ( ) та downloadCheckins ( ) .
З кожним розширенням цей код буде дедалі ставати складнішим : при додаванні кожного нового методу , у котрому ми змінюємо модель , слід проінспектувати кожен існуючий метод , що змінює модель , і перевірити його коректність .
Тому з масштабуванням така реалізація буде все більш і більш заплутаною , і у ній все частіше з'являтимуться баги .
Не кажучи вже про неминуче переростання у Massive View Controller .
Знаю , знаю , ви вже проходили через ці граблі , і вже давно обрали для себе MVVM / VIPER / Redux / RIBs , а дехто вже втопив усі ті кляті язичницькі в'ю -контролери у річці , приєднавшись до Української SwiftUI - автокефалії .
Однак , наступний спосіб " кудись втулити стейт - машину " жодним чином не має суперечити вашим релігійним переконанням , скоріше допоможу їм ствердитись .
Ліпимо однонаправлені архітектури зі стейт - машинами
Ідея проста : виокремити з в'юконтролера певні відповідальності у окремі компоненти , і об'єднати їх однонаправленим зв'язком наступним чином :
<схема >
ViewController тепер відповідатиме лише за відображення даних , і передаватиме згенеровані користувачем дії до інтерактора .
Interactor знає про різноманітні сервіси нашого додатку і реалізовує взаємодію ( тобто інтеракцію ) з ними .
У нашому випадку – це сервіс з завантаження чекінів та аутентифікаційний сервіс .
State Machine реагує на подій , котрі приходять з інтерактора , та реалізовує логіку зміни стану в залежнсоті від події .
ViewController спостерігає за станом стейт - машини та відображає його .
Фактично , все , що зображує ViewController , залежить виключно від стану State Machine , іншими словами , UI цього в'ю-контролера є чистою функцією стану .
Чуєте , як запахло хайпом ?
Та це ж головний принцип SwiftUI !
Дійсно , даний підхід є абсолютно природнім і для SwiftUI :
<схема >
Давайте переробимо все на однонаправлену архітектуру зі стейт - машинами .
Тільки спершу ми відійдемо на крок назад , і реалізуємо версію без логінів - логаутів .
Це дозволить нам перевірити наш підхід на гнучкість : ми реалізовуємо просту задачу , а потім в рамках цієї реалізації пробуємо додавати нову функціональність , як ми це робили вище .
Спершу ми створимо стейт - машину , котра опише логіку переходів .
Ми одразу ж реалізуємо спостереження за станом цієї стейт машини :
<код>
Тепер створимо інтерактор , котрий володітиме даною стейт - машиною .
Інтерактор повинен спілкуватись із сервісами рівня додатку :
<код>
Тепер в'ю - контролер стає простим , як дошка - сороківка :
<код>
Як буде мінятись наша нова реалізація , якщо додати в неї стан . loggedOut та кнопку logOut ?
У першу чергу зміниться стейт - машина : у ній з'явиться новиий стан та нова подія .
При цьому логіка всередині її не стане складнішою , вона просто стане довшою .
Це і є тією чарівною особливістю стейт - машин , за яку я так їх люблю : вони перетворюють нелінійний код на лінійний , і тому при ускладненні задачі масштабуються лінійно .
And I think it's beautiful :
<код>
Так , метод transition( with : ) став довшим , але він не став складнішим , а всі можливі варіанти взаємодії нових станів та подій знаходяться в одному місці , і тому нам легко стежити за коректністю усіх переходів .
До того ж , властивість вичерпності інструкції switch повіністю або частково , як у цьому випадку , допомагає нам слідкувати за коректністю коду вже під час компіляції .
Як зміниться інтерактор ?
Ми додамо у нього нову залежність на AuthService , та новий метод logout ( ) , котрим користуватиметься наш в'ю-контролер .
Вже існуючий метод loadCheckins ( ) не стане від цього складнішим , як минулого разу , він узагалі не зміниться :
<код>
Зміни у в'ю - контролері будуть тривіальними : слід просто викликати ще один метод інтерактора , то відображати іще один стан .
Тому ми їх опустимо .
На сьогодні все
Стейт - машини не є срібною кулею , як і будь-який інший патерн проєктування , вони не зроблять ваш код ідеальним , не зроблять ваші проекти цікавішими і не закінчать епоху бідності вже сьогодні .
Однак вони мають дуже зручну властивість перетворювати нелінійлу логіку у лінійну , чим часом дуже сильно спрощують наш код .
Вони універсальні , тому вони знаходять місце на будь-якому рівні абстракції ваших додатків .
Також вони допомагають виокремити з будь-якої компоненти логіку у чистому вигляді , що дозволяє досить просто покрити її тестами .
Власне , наступного разу ми поговоримо про покриття стейт - машин тестами .
Також у наступних частинах я би хотів поговорити про різновиди ієрархічні та ієрархічно - ортогональні стейт - машини та про задачі , котрі вони дозволяють розв'язувати у простий та елегантний спосіб .
Приклади коду , з яким ми мали щастя працювати вище , можна скачати тут .