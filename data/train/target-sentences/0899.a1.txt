Скінченні автомати можуть викликати моторошні в'єтнамські флешбеки про незалік з теорії алгоритмів, від них може віяти смутком чорно-білих сторінок даташитів якихось мікрочипів, і коли я питаю на співбесідах iOS-розробників про їхні улюблені шаблони – скінченні автомати є точно не найчастішою відповіддю.
Вони точно не можуть конкурувати в хайповості з усілякими модними патернами світу iOS-розробки на кшталт VIPER, RIBs, Redux чи MVVM.
Однак скінченні автомати, або Finite State Machines, – це абсолютно незаслужено забутий шаблон проєктування, що робить життя iOS-розробника простішим і зрозумілішим.
Сьогодні ми з вами спробуємо поглянути на нього по-новому і знайти у своїх проєктах місце для цієї простої та універсальної абстракції.
Про скінченні автомати
Перш ніж почати, домовмось називати скінченні автомати просто й по-народному: стейт-машинами.
Це не зовсім коректний переклад цього терміна, але в коридорах наших ІТ-компаній ви, найімовірніше, почуєте саме цей варіант, адже лютий англо-український техносурж – це і є той правдивий варіант української, котрим спілкуються інженери за межами книжок про програмування.
Отож, почнемо.
Що таке стейт-машина?
Це спосіб описати роботу якогось пристрою.
Уявімо собі, що в нас є холодильник.
Він працює дуже просто: якийсь час він охолоджує свою камеру, а потім якийсь час чекає, доки камера нагріється до максимально допустимої температури.
Фактично, в нього є два режими роботи: охолодження та очікування.
Ці режими ми називатимемо станами.
Холодильник перемикається між своїми станами лише у випадку настання певних подій, зокрема:
температура опустилась нижче мінімуму
температура піднялась вище максимуму
Ці події змушують холодильник переходити з одного стану в інший:
<схема>
Таке зображення роботи холодильника ми і називаємо стейт-машиною, або машиною із скінченними станами.
Будь-який пристрій, який у різний час веде себе по-різному, можна описати за допомогою стейт-машини.
Перевага цієї форми в тому, що вона є інтуїтивно зрозумілою.
Наприклад, зовсім не складно зрозуміти алгоритм роботи якоїсь програми, коли його записано так:
<схема>
Окрім того, що ця форма є зрозумілою, вона є повною.
Зі схеми вище зрозуміло, що операцію скасування (cancel) можна виконати тоді, коли ця програма перебуває у стані Processing, але не можна виконати тоді, коли програма перебуває у стані Loading.
Лише уявіть, якби ваш замовник описував вам вимоги до вашої програми, послуговуючись мовою стейт-машин, скільки безцінних годин життя ви могли би зекономити?
Простота й універсальність цієї форми представлення інформації ставить її в один ряд із діаграмами Венна та діаграмами Ґанта.
Мова програмування Swift дозволяє дуже просто реалізовувати стейт-машини.
Спробуймо описати роботу холодильника:
<код>
Це лише один зі способів представити скінченний автомат мовою Swift, існує багато інших, часто нічим не гірших, а іноді навіть і чимось кращих за даний.
Перевагою цього запису скінченного автомата є використання вичерпності інструкції switch у Swift.
Якщо завтра нам доведеться реалізовувати новий стан, компілятор змусить нас подумати про те, як слід реагувати на кожну з існуючих подій у цьому новому стані.
Те саме працюватиме з новими подіями.
<код>
Те саме стосується й нових подій.
Коли ми додаємо якусь нову подію, компілятор змушує нас подумати: в яких станах доречно реагувати на нову подію, а в яких — ні?
<код>
Проєктуємо, використовуючи скінченні автомати
Ясна річ, скінченні автомати можна застосовувати не лише при проєктуванні холодильників.
Ми — iOS-інженери: ми не будуємо холодильники, а проєктуємо інтерфейси та скролимо списки.
Спробуймо втулити стейт-машину куди-небудь у якийсь код, який вирішував би реальну задачу.
Уявімо собі, що нам потрібно реалізувати кнопки "Shift" на мобільній клавіатурі.
Вона відрізняється від кнопок на фізичній клавіатурі тим, що фактично поєднує логіку кнопок Caps Lock та Shift в одній кнопці, тому вона має три стани: Off, On, та CapsLock.
Залежно від швидкості і кількості натискань на кнопку, її стан змінюються так:
Shift state machine
Спробувавши лаконічно пояснити, як повинна працювати кнопка, ми, власне, й побудували стейт-машину, і тепер лишилось перетворити її на код.
<код>
Реалізація стейт-машини нескладна, і не вимагає додаткових коментарів.
Користувач цієї стейт-машини повинен робити дві речі: надсилати події та міняти UI залежно від стану цієї стейт-машини.
Слід, утім, звернути увагу на те, чого в цьому коді немає.
Тут немає роботи з конкретними UI-елементами.
Тут узагалі немає жодних залежностей.
Логіка кнопки живе окремо, а UI – окрема.
Ми, наприклад, можемо переписати UI з UIKit на SwiftUI, при цьому логіка не зміниться.
Зручно, чи не так?
Приклад з таблицею
Розгляньмо більш життєвий приклад.
Нехай ми будуємо додаток, в якому користувач може відмічати різні пам'ятки та цікаві місця, котрі він відвідав, і нам потрібно відобразити список цих пам'яток.
Та що там робити, UITableViewController чи List зі SwiftUI, 15 хвилин — і готово.
<Скріншот додатка зі списком чекінів>
Щоправда, якщо ми хочемо, щоб цим списком користувались живі люди, і щоб їм було зручно, то нам варто подумати про багато нюансів.
Наприклад, коли список порожній — користувач побачить просто білий екран.
І в нашого користувача будуть питання: де я?
Чому екран порожній?
Це якась помилка?
Чи просто поки що немає даних?
Тому якщо ми любимо свого користувача, то покажемо йому якесь пояснення:
Як не варто показувати порожні списки:
Як слід показувати порожні списки:
<Скріншот додатка з неправильним порожнім списком>  |<Скріншот додатка з правильним порожнім списком>
Якщо ми зберігатимемо дані користувачів на сервері, то користувач побачить свої чекіни не одразу, йому слід буде почекати, допоки не завантажаться дані.
І знову ж таки, якщо ми любимо свого користувача, ми не полінимось пояснити йому, що ж відбувається, показавши екран із завантаженням:
<Скріншот додатка зі завантаженням списку>
Врешті, не всяке завантаження даних із мережі закінчується успішно, виникнення помилки в такому випадку є цілком штатною ситуацією.
Шибати UIAlertController в обличчя користувача щоразу, коли він зайшов у підземний перехід і в нього зникло інтернет-з'єднання — це насправді трохи навіть грубо, більш доречним буде вбудувати повідомлення про помилку в сам екран, турботливо поклавши до нього кнопочку "Спробуй ще" (як колись писали під кришечками акційної Фанти).
<Скріншот додатка з помилкою завантаження>
Коли проєктуєш модель даних для такого списку, дуже допомагає вчасне усвідомлення, що модель не повинна бути структурою, вона повинна бути перечисленням.
Справді, ми показуємо або список, або екран із завантаженням, або екран з помилкою, або екран з повідомленням про те, що немає даних:
<код>
Однак такою моделлю даних потрібно якось керувати.
А ще треба якось реагувати на зміни у цій моделі, не ускладнюючи код.
Уявімо собі, що ми керуємо цією моделлю напряму у в'ю-контролері:
<код>
Як бачимо у прикладі вище, у простих випадках керувати такою моделлю нескладно, однак при збільшенні кількості елементів у перечисленні CheckinListViewData, що служить нашою моделлю, збільшується і складність нашого коду.
Уявімо собі, що ми хочемо реалізувати принцип "відкладеного логіну", коли користувач може послуговуватись значною частиною функціональності додатка, не аутентифікацію, і змушений логінитись лише в момент, коли це дійсно необхідно.
У такому додатку на екран зі списком пам'яток може потрапити неаутентифікований користувач, і це є штатною ситуацією:
<Скріншот додатка з необхідністю залогінитись>
Для реалізації такої поведінки нам потрібно додати новий стан до нашої моделі:
<код>
Бачимо, що тепер нам потрібно міняти нашу модель у різних місцях, з різних причин і при цьому тримати її консистентною.
Саме з цих причин у нас з'являються інструкції guard на початку методів logoutPressed() та downloadCheckins().
З кожним розширенням цей код буде ставати дедалі складнішим: при додаванні кожного нового методу, у котрому ми змінюємо модель, слід проінспектувати кожен існуючий метод, що змінює модель, і перевірити його коректність.
Тому з масштабуванням така реалізація буде все більш заплутаною, і у ній дедалі частіше з'являтимуться баги.
Не кажучи вже про неминуче переростання у Massive View Controller.
Знаю-знаю, ви вже наступали на ці граблі і вже давно обрали для себе MVVM/VIPER/Redux/RIBs, а дехто вже втопив усі ті кляті язичницькі в'ю-контролери у річці, приєднавшись до Української SwiftUI-автокефалії.
Однак наступний спосіб "кудись втулити стейт-машину" аж ніяк не має суперечити вашим релігійним переконанням, скоріше допомогти їм ствердитись.
Ліпимо однонаправлені архітектури зі стейт-машинами
Ідея проста: виокремити з в`ю-контролера певні відповідальності в окремі компоненти, і об'єднати їх однонаправленим зв'язком таким чином:
<схема>
ViewController тепер відповідатиме лише за відображення даних і передаватиме згенеровані користувачем дії до інтерактора.
Interactor знає про різноманітні сервіси нашого додатка і реалізовує взаємодію (тобто інтеракцію) з ними.
У нашому випадку – це сервіс зі завантаження чекінів та аутентифікаційний сервіс.
State Machine реагує на події, котрі приходять з інтерактора, та реалізовує логіку зміни стану залежно від події.
ViewController спостерігає за станом стейт-машини та відображає його.
Фактично, все, що зображує ViewController, залежить виключно від стану State Machine, іншими словами, UI цього в'ю-контролера є чистою функцією стану.
Чуєте, як запахло хайпом?
Та це ж головний принцип SwiftUI!
Справді, цей підхід є абсолютно природним і для SwiftUI:
<схема>
Переробимо все на однонаправлену архітектуру зі стейт-машинами.
Тільки спершу ми відійдемо на крок назад і реалізуємо версію без логінів-логаутів.
Це дозволить нам перевірити наш підхід на гнучкість: ми реалізовуємо просту задачу, а потім в рамках цієї реалізації пробуємо додавати нову функціональність, як ми це робили вище.
Спершу ми створимо стейт-машину, котра опише логіку переходів.
Ми одразу ж реалізуємо спостереження за станом цієї стейт-машини:
<код>
Тепер створимо інтерактор, котрий володітиме цією стейт-машиною.
Інтерактор повинен спілкуватись із сервісами рівня додатка:
<код>
Тепер в'ю-контролер стає простим, як дошка-сороківка:
<код>
Як мінятиметься наша нова реалізація, якщо додати в неї стан .loggedOut та кнопку logOut?
Передусім зміниться стейт-машина: у ній з'явиться новий стан та нова подія.
При цьому логіка всередині її не стане складнішою, вона просто стане довшою.
Це і є тією чарівною особливістю стейт-машин, за яку я так їх люблю: вони перетворюють нелінійний код на лінійний і тому при ускладненні задачі масштабуються лінійно.
And I think it's beautiful:
<код>
Так, метод transition(with:) став довшим, але він не став складнішим, а всі можливі варіанти взаємодії нових станів та подій перебувають в одному місці, і тому нам легко стежити за коректністю усіх переходів.
До того ж, властивість вичерпності інструкції switch повністю або частково, як у цьому випадку, допомагає нам стежити за коректністю коду вже під час компіляції.
Як зміниться інтерактор?
Ми додамо у нього нову залежність на AuthService та новий метод logout(), котрим користуватиметься наш в'ю-контролер.
Вже існуючий метод loadCheckins() не стане від цього складнішим, як минулого разу, він узагалі не зміниться:
<код>
Зміни у в'ю-контролері будуть тривіальними: слід просто викликати ще один метод інтерактора та відображати іще один стан.
Тому ми їх опустимо.
На сьогодні все
Стейт-машини не є срібною кулею, як і будь-який інший патерн проєктування, вони не зроблять ваш код ідеальним, не зроблять ваші проєкти цікавішими і не закінчать епоху бідності вже сьогодні.
Однак вони мають дуже зручну властивість перетворювати нелінійну логіку у лінійну, чим часом дуже сильно спрощують наш код.
Вони універсальні, тому знаходять місце на будь-якому рівні абстракції ваших додатків.
Також вони допомагають виокремити з будь-якої компоненти логіку у чистому вигляді, що дозволяє досить просто покрити її тестами.
Власне, наступного разу ми поговоримо про покриття стейт-машин тестами.
Також у наступних частинах я би хотів поговорити про різновиди ієрархічні та ієрархічно-ортогональні стейт-машини і про задачі, котрі вони дозволяють розв'язувати у простий та елегантний спосіб.
Приклади коду, з яким ми мали щастя працювати вище, можна скачати тут.