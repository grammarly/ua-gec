S Скінченні автомати можуть викликати моторошні в'єтнамські флешбеки про незалік з теорії алгоритмів , від них може віяти смутком чорнобілих сторінок даташитів якихось мікрочіпів , і коли я питаю на співбесідах iOS - розробників про їх улюблені шаблони – скінченні автомати є точно не найбільш частою відповіддю .
A 18 19|||Spelling|||чорно - білих|||REQUIRED|||-NONE-|||1
A 22 23|||Spelling|||мікрочипів|||REQUIRED|||-NONE-|||1
A 34 35|||G/Other|||їхні|||REQUIRED|||-NONE-|||1
A 37 38|||Punctuation|||—|||REQUIRED|||-NONE-|||1
A 43 45|||G/Comparison|||найчастішою|||REQUIRED|||-NONE-|||1

S Вони точно не можуть конкурувати в хайповості з усіляким модними паттернами світу iOS - розробки на кшталт VIPER , RIBs , Redux чи MVVM .
A 8 9|||G/Number|||усілякими|||REQUIRED|||-NONE-|||1
A 10 11|||Spelling|||патернами|||REQUIRED|||-NONE-|||1

S Однак , скінченні автомати , або Finite State Machines , – це абсолютно незаслужено забутий шаблон проектування , що робить життя iOS - розробника простішим і зрозумілішим .
A 1 2|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 16 17|||Spelling|||проєктування|||REQUIRED|||-NONE-|||1

S Сьогодні ми з вами спробуємо поглянути на нього по-новому , і знайти у своїх проектах місце для цієї простої та універсальної абстракції .
A 9 10|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 14 15|||Spelling|||проєктах|||REQUIRED|||-NONE-|||1

S Про скінченні автомати
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Перш ніж почати , давайте домовимось називати скінченні автомати просто й по-народному : стейт - машинами .
A 4 6|||G/VerbAForm|||домовмось|||REQUIRED|||-NONE-|||1

S Це не зовсім коректний переклад цього терміну , але в коридорах наших ІТ-компаній ви , найімовірніше , почуєте саме цей варіант , адже лютий англоукраїнський техносурж – це і є той правдивий варіант української , котрим спілкуються інженери за межами книжок про програмування .
A 6 7|||G/Case|||терміна|||REQUIRED|||-NONE-|||1
A 24 25|||Spelling|||англо - український|||REQUIRED|||-NONE-|||1
A 26 27|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S Отож , почнемо .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Що таке стейт - машина ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Це спосіб описати роботу якогось пристрою .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Уявімо собі , що в нас є холодильник .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Він працює дуже просто : якийсь час він охолоджує свою камеру , а потім якийсь час чекає , доки камера нагріється до максимально допустимої температури .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Фактично , в нього є два режими роботи : охолодження та очікування .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ці режими ми називатимемо станами .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Холодильник переключається між своїми станами лише у випадку настання певних подій , зокрема :
A 1 2|||F/Style|||перемикається|||REQUIRED|||-NONE-|||1

S температура опустилась нижче мінімуму
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S температура піднялась вишче максимуму
A 2 3|||Spelling|||вище|||REQUIRED|||-NONE-|||1

S Ці події змушують холодильник переходити з одного стану в інший :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <схема >
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Таке зрображення роботи холодильника ми і називаємо стейт - машиною , або машиною із скінченними станами .
A 1 2|||Spelling|||зображення|||REQUIRED|||-NONE-|||1

S Будь-який пристрій , який в різний час веде себе по-різному , можна описати за допомогою стейт - машини .
A 4 5|||Spelling|||у|||REQUIRED|||-NONE-|||1

S Перевага цієї форми в тому , що вона є інтуїтивно зрозумілою .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Наприклад , зовсім не складно зрозуміти алгоритм роботи якоїсь програми , коли його записано так :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <схема >
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Окрім того , що ця форма є зрозумілою , вона є повною .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Зі схеми вище зрозуміло , що операцію скасування ( cancel ) можна виконати тоді , коли ця програма знаходиться у стані Processing , але не можна виконати тоді , коли програма знаходиться у стані Loading .
A 18 19|||F/Collocation|||перебуває|||REQUIRED|||-NONE-|||1
A 31 32|||F/Collocation|||перебуває|||REQUIRED|||-NONE-|||1

S Лише уявіть , якби ваш замовник описував вам вимоги до вашої програми , послуговуючись мовою стейт - машин , скільки би безцінних годин життя ви могли би зекономити ?
A 20 21|||G/UngrammaticalStructure|||-NONE-|||REQUIRED|||-NONE-|||1

S Простота і універсальність цієї форми представлення інформації ставить її в один ряд з діаграмами Венна та діаграмами Ґанта .
A 1 2|||Spelling|||й|||REQUIRED|||-NONE-|||1
A 12 13|||Spelling|||із|||REQUIRED|||-NONE-|||1

S Мова програмування Swift дозволяє дуже просто реалізовувати стейт - машини .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Давайте спробуємо описати роботу холодильника :
A 0 2|||G/VerbAForm|||Спробуймо|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Це лише один зі способів представити скінченний автомат мовою Swift , існує багато інших , часто нічим не гірших , а іноді навіть і чимось кращих за даний .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Перевагою даного запису скінченного автомата є використання вичерпності інструкції switch у Swift .
A 1 2|||F/Calque|||цього|||REQUIRED|||-NONE-|||1

S Якщо завтра нам доведеться реалізовувати новий стан , компілятор змусить нас подумати про те , як слід реагувати на кожну з існуючих подій в цьому новому стані .
A 23 24|||Spelling|||у|||REQUIRED|||-NONE-|||1

S Це ж саме працюватиме з новими подіями .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Те ж саме стосується й нових подій .
A 1 2|||G/UngrammaticalStructure|||-NONE-|||REQUIRED|||-NONE-|||1

S Коли ми додаємо якусь нову подію , компілятор змушує нас подумати : в яких станах доречно реагувати на нову подію , а в яких ні ?
A 24 24|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Проєктуємо , використовуючи скінченні автомати
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ясна річ , скінченні автомати можна застосовувати не лише при проєктуванні холодильників .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ми iOS інженери : ми не будуємо холодильники , ми проєктуємо інтерфейси та скролимо списки .
A 1 1|||Punctuation|||—|||REQUIRED|||-NONE-|||1
A 2 2|||Punctuation|||-|||REQUIRED|||-NONE-|||1
A 9 10|||F/Repetition|||а|||REQUIRED|||-NONE-|||1

S Давайте спробуємо втулити стейт - машину куди -небудь в якийсь код , котрий вирішував би реальну задачу .
A 0 2|||G/VerbAForm|||Спробуймо|||REQUIRED|||-NONE-|||1
A 8 9|||Spelling|||у|||REQUIRED|||-NONE-|||1
A 12 13|||G/Conjunction|||який|||REQUIRED|||-NONE-|||1

S Уявімо собі , що нам потрібно реалізувати кнопки " Shift " на мобільній клавіатурі .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Вона відрізняється від кнопок на фізичній клавіатурі тим , що фактично поєднує логіку кнопок Caps Lock та Shift в одній кнопці , тому вона має три стани : Off , On , та CapsLock .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S В залежності від швидкості і кількості натискать на кнопку , її стан змінюються наступним чином :
A 0 2|||F/PoorFlow|||Залежно|||REQUIRED|||-NONE-|||1
A 6 7|||Spelling|||натискань|||REQUIRED|||-NONE-|||1
A 13 15|||F/Calque|||так|||REQUIRED|||-NONE-|||1

S Shift state machine
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Спробувавши лаконічно пояснити , як повинна працювати кнопка , ми , власне , й побудували стейт - машину , і тепер лишилось перетворити її на код .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Реалізація стейт - машини нескладна , і не вимигає додаткових коментарів .
A 8 9|||Spelling|||вимагає|||REQUIRED|||-NONE-|||1

S Користувач цієї стейт - машини повинен робити дві речі : надсилати події , та міняти UI в залежності від стану цієї стейт - машини .
A 12 13|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 16 17|||F/PoorFlow|||-NONE-|||REQUIRED|||-NONE-|||1
A 17 18|||F/PoorFlow|||залежно|||REQUIRED|||-NONE-|||1

S Слід , утім , звернути увагу на те , чого в цьому коді немає .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Тут немає роботи з конкретними UI-елементами .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Тут взагалі немає жодних залежностей .
A 1 2|||Spelling|||узагалі|||REQUIRED|||-NONE-|||1

S Логіка кнопки живе окремо , а UI – окрема .
A 7 8|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S Ми , наприклад , можемо переписати UI з UIKit на SwiftUI , при цьому логіка не зміниться .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Зручно , чи не так ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Приклад з таблицею
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Давайте розглянемо більш життєвий приклад .
A 0 2|||G/VerbAForm|||Розгляньмо|||REQUIRED|||-NONE-|||1

S Нехай ми будуємо додаток , в якому користувач може відмічати різні пам'ятки та цікаві місця , котрі він відвідав , і нам потрібно відобразити список цих пам'яток .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Та що там робити , UITableViewController чи List зі SwiftUI , 15 хвилин - і готово .
A 13 14|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S < Скріншот додатку зі списком чекінів >
A 2 3|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S Щоправда , якщо ми хочемо , щоб цим списком користувались живі люди , і щоб їм було зручно , то нам варто подумати про багато нюансів .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Наприклад , коли список порожній - користувач побачить просто білий екран .
A 5 6|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S І в нашого користувача будуть питання : де я ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Чому екран порожній ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Це якась помилка ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Чи просто поки що немає данних ?
A 5 6|||Spelling|||даних|||REQUIRED|||-NONE-|||1

S Тому , якщо ми любимо свого користувача , ми покажемо йому якесь пояснення :
A 1 2|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 8 9|||F/Repetition|||то|||REQUIRED|||-NONE-|||1

S Як не варто показуватии порожні списки :
A 3 4|||Spelling|||показувати|||REQUIRED|||-NONE-|||1

S Як слід показуватии порожні списки :
A 2 3|||Spelling|||показувати|||REQUIRED|||-NONE-|||1

S < Скріншот додатку з неправильним порожнім списком> | <Скріншот додатку з правильним порожнім списком >
A 2 3|||G/Case|||додатка|||REQUIRED|||-NONE-|||1
A 9 10|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S Якщо ми зберігатимемо дані користувачів на сервері , то користувач побачить свої чекіни не одразу , йому слід буде почекати , допоки не завантажаться дані .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S І знову ж таки , якщо ми любимо свого користувача , ми не полінимось пояснити йому , що ж відбувається , показавши екран із завантаженням :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S < Скріншот додатку з завантаженням списку >
A 2 3|||G/Case|||додатка|||REQUIRED|||-NONE-|||1
A 3 4|||Spelling|||зі|||REQUIRED|||-NONE-|||1

S Врешті , не всяке завантаження даних із мережі закінчується успішно , виникнення помилки в такому випадку є цілком штатною ситуацією .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Шибати UIAlertController в обличчя користувача щоразу , коли він зайшов у підземний перехід і в нього пропало інтернет - з'єднання - це насправді трохи навіть грубо , більш доречним буде вбудувати повідомлення про помилку в сам екран , турботливо поклавши до нього кнопочку " Спробуй ще " ( як колись писали під кришечками акційної Фанти ) .
A 16 17|||F/Style|||зникло|||REQUIRED|||-NONE-|||1
A 20 21|||Punctuation|||—|||REQUIRED|||-NONE-|||1

S < Скріншот додатку з помилкою завантаження >
A 2 3|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S Коли проектуєш модель даних для такого списку , дуже допомагає вчасне усвідомлення , що модель не повинна бути структурою , вона повинна бути перечисленням .
A 1 2|||Spelling|||проєктуєш|||REQUIRED|||-NONE-|||1

S Дійсно , ми показуємо або список , або екран із завантаженням , або екран з помилкою , або екран з повідоменням про те , що немає даних :
A 0 1|||F/Style|||Справді|||REQUIRED|||-NONE-|||1
A 20 21|||Spelling|||повідомленням|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Однак , такою моделлю даних потрібно якось керувати .
A 1 2|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S А ще треба якось реагувати на зміни у даній моделі , не ускладнюючи код .
A 8 9|||F/Calque|||цій|||REQUIRED|||-NONE-|||1

S Уявімо собі , що ми керуємо даною моделлю напряму у в'ю - контролері :
A 6 7|||F/Calque|||цією|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Як бачимо у прикладі вище , у простих випадках керувати такою моделлю нескладно , однак при збільшенні кількості елементів у перечисленні CheckinListViewData , що служить нашою моделлю , збільшується і складність нашого коду .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Уявімо собі , що ми хочемо реалізувати принцип " відкладеного логіну " , коли користувач може послуговуватись значною частиною функціональністі додатку не аутентифікувавшись , і змушений логінитись лише в момент , коли це дійсно необхідно .
A 19 20|||Spelling|||функціональності|||REQUIRED|||-NONE-|||1
A 20 21|||G/Case|||додатка|||REQUIRED|||-NONE-|||1
A 21 21|||Punctuation|||,|||REQUIRED|||-NONE-|||1
A 22 23|||G/UngrammaticalStructure|||аутентифікацію|||REQUIRED|||-NONE-|||1

S В такому додатку на екран зі списоком пам'яток може потрапити неаутентифікований користувач , і це є штатною ситуацією :
A 0 1|||Spelling|||У|||REQUIRED|||-NONE-|||1
A 6 7|||Spelling|||списком|||REQUIRED|||-NONE-|||1

S < Скріншот додатку з необхідністю залогінитись >
A 2 3|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S Для реалізації такої поведінки , нам потрібно додати новий стан до нашої моделі :
A 4 5|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Бачимо , що тепер нам потрібно міняти нашу модель у різних місцях , з різних причин , і при цьому тримати її консистентною .
A 16 17|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S Саме з цих причин у нас з'являються інструкції guard на початку методів logoutPressed ( ) та downloadCheckins( ) .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S З кожним розширенням цей код буде дедалі ставати складнішим : при додаванні кожного нового методу , у котрому ми змінюємо модель , слід проінспектувати кожен існуючий метод , що змінює модель , і перевірити його коректність .
A 6 6|||F/PoorFlow|||ставати|||REQUIRED|||-NONE-|||1
A 7 8|||F/PoorFlow|||-NONE-|||REQUIRED|||-NONE-|||1

S Тому з масштабуванням така реалізація буде все більш і більш заплутаною , і у ній все частіше з'являтимуться баги .
A 8 10|||F/Repetition|||-NONE-|||REQUIRED|||-NONE-|||1
A 15 16|||F/Calque|||дедалі|||REQUIRED|||-NONE-|||1

S Не кажучи вже про неминуче переростання у Massive View Controller .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Знаю , знаю , ви вже проходили через ці граблі , і вже давно обрали для себе MVVM / VIPER / Redux / RIBs , а дехто вже втопив усі ті кляті язичницькі в'ю - контролери у річці , приєднавшись до Української SwiftUI - автокефалії .
A 1 2|||Punctuation|||-|||REQUIRED|||-NONE-|||1
A 6 8|||F/Collocation|||наступали на|||REQUIRED|||-NONE-|||1
A 10 11|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S Однак , наступний спосіб " кудись втулити стейт - машину " жодним чином не має суперечити вашим релігійним переконанням , скоріше допоможу їм ствердитись .
A 1 2|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 11 13|||F/PoorFlow|||аж ніяк|||REQUIRED|||-NONE-|||1
A 21 22|||G/UngrammaticalStructure|||допомогти|||REQUIRED|||-NONE-|||1

S Ліпимо однонаправлені архітектури зі стейт - машинами
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ідея проста : виокремити з в'юконтролера певні відповідальності у окремі компоненти , і об'єднати їх однонаправленим зв'язком наступним чином :
A 5 6|||Spelling|||в`ю - контролера|||REQUIRED|||-NONE-|||1
A 8 9|||Spelling|||в|||REQUIRED|||-NONE-|||1
A 17 18|||F/Calque|||таким|||REQUIRED|||-NONE-|||1

S <схема >
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S ViewController тепер відповідатиме лише за відображення даних , і передаватиме згенеровані користувачем дії до інтерактора .
A 7 8|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S Interactor знає про різноманітні сервіси нашого додатку і реалізовує взаємодію ( тобто інтеракцію ) з ними .
A 6 7|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S У нашому випадку – це сервіс з завантаження чекінів та аутентифікаційний сервіс .
A 3 4|||Punctuation|||—|||REQUIRED|||-NONE-|||1
A 6 7|||Spelling|||зі|||REQUIRED|||-NONE-|||1

S State Machine реагує на подій , котрі приходять з інтерактора , та реалізовує логіку зміни стану в залежнсоті від події .
A 4 5|||G/Case|||події|||REQUIRED|||-NONE-|||1
A 16 17|||F/PoorFlow|||-NONE-|||REQUIRED|||-NONE-|||1
A 17 18|||Spelling|||залежно|||REQUIRED|||-NONE-|||1

S ViewController спостерігає за станом стейт - машини та відображає його .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Фактично , все , що зображує ViewController , залежить виключно від стану State Machine , іншими словами , UI цього в'ю -контролера є чистою функцією стану .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Чуєте , як запахло хайпом ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Та це ж головний принцип SwiftUI !
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Дійсно , даний підхід є абсолютно природнім і для SwiftUI :
A 0 1|||F/Style|||Справді|||REQUIRED|||-NONE-|||1
A 2 3|||F/Calque|||цей|||REQUIRED|||-NONE-|||1
A 6 7|||F/Style|||природним|||REQUIRED|||-NONE-|||1

S <схема >
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Давайте переробимо все на однонаправлену архітектуру зі стейт - машинами .
A 0 2|||G/VerbAForm|||Переробимо|||REQUIRED|||-NONE-|||1

S Тільки спершу ми відійдемо на крок назад , і реалізуємо версію без логінів - логаутів .
A 7 8|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S Це дозволить нам перевірити наш підхід на гнучкість : ми реалізовуємо просту задачу , а потім в рамках цієї реалізації пробуємо додавати нову функціональність , як ми це робили вище .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Спершу ми створимо стейт - машину , котра опише логіку переходів .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ми одразу ж реалізуємо спостереження за станом цієї стейт машини :
A 9 9|||Spelling|||-|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Тепер створимо інтерактор , котрий володітиме даною стейт - машиною .
A 6 7|||F/Calque|||цією|||REQUIRED|||-NONE-|||1

S Інтерактор повинен спілкуватись із сервісами рівня додатку :
A 6 7|||G/Case|||додатка|||REQUIRED|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Тепер в'ю -контролер стає простим , як дошка - сороківка :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Як буде мінятись наша нова реалізація , якщо додати в неї стан . loggedOut та кнопку logOut ?
A 1 2|||F/PoorFlow|||-NONE-|||REQUIRED|||-NONE-|||1
A 2 3|||G/Tense|||мінятиметься|||REQUIRED|||-NONE-|||1

S У першу чергу зміниться стейт - машина : у ній з'явиться новиий стан та нова подія .
A 0 3|||F/Calque|||Передусім|||REQUIRED|||-NONE-|||1
A 11 12|||Spelling|||новий|||REQUIRED|||-NONE-|||1

S При цьому логіка всередині її не стане складнішою , вона просто стане довшою .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Це і є тією чарівною особливістю стейт - машин , за яку я так їх люблю : вони перетворюють нелінійний код на лінійний , і тому при ускладненні задачі масштабуються лінійно .
A 23 24|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S And I think it's beautiful :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Так , метод transition( with : ) став довшим , але він не став складнішим , а всі можливі варіанти взаємодії нових станів та подій знаходяться в одному місці , і тому нам легко стежити за коректністю усіх переходів .
A 25 26|||F/Collocation|||перебувають|||REQUIRED|||-NONE-|||1

S До того ж , властивість вичерпності інструкції switch повіністю або частково , як у цьому випадку , допомагає нам слідкувати за коректністю коду вже під час компіляції .
A 8 9|||Spelling|||повністю|||REQUIRED|||-NONE-|||1
A 19 20|||F/Style|||стежити|||REQUIRED|||-NONE-|||1

S Як зміниться інтерактор ?
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Ми додамо у нього нову залежність на AuthService , та новий метод logout ( ) , котрим користуватиметься наш в'ю - контролер .
A 8 9|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1

S Вже існуючий метод loadCheckins ( ) не стане від цього складнішим , як минулого разу , він узагалі не зміниться :
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S <код>
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Зміни у в'ю -контролері будуть тривіальними : слід просто викликати ще один метод інтерактора , то відображати іще один стан .
A 14 15|||Punctuation|||-NONE-|||REQUIRED|||-NONE-|||1
A 15 16|||Spelling|||та|||REQUIRED|||-NONE-|||1

S Тому ми їх опустимо .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S На сьогодні все
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Стейт - машини не є срібною кулею , як і будь-який інший патерн проєктування , вони не зроблять ваш код ідеальним , не зроблять ваші проекти цікавішими і не закінчать епоху бідності вже сьогодні .
A 25 26|||Spelling|||проєкти|||REQUIRED|||-NONE-|||1

S Однак вони мають дуже зручну властивість перетворювати нелінійлу логіку у лінійну , чим часом дуже сильно спрощують наш код .
A 7 8|||Spelling|||нелінійну|||REQUIRED|||-NONE-|||1

S Вони універсальні , тому вони знаходять місце на будь-якому рівні абстракції ваших додатків .
A 4 5|||F/Repetition|||-NONE-|||REQUIRED|||-NONE-|||1

S Також вони допомагають виокремити з будь-якої компоненти логіку у чистому вигляді , що дозволяє досить просто покрити її тестами .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Власне , наступного разу ми поговоримо про покриття стейт - машин тестами .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

S Також у наступних частинах я би хотів поговорити про різновиди ієрархічні та ієрархічно - ортогональні стейт - машини та про задачі , котрі вони дозволяють розв'язувати у простий та елегантний спосіб .
A 18 19|||F/Repetition|||і|||REQUIRED|||-NONE-|||1

S Приклади коду , з яким ми мали щастя працювати вище , можна скачати тут .
A -1 -1|||noop|||-NONE-|||-NONE-|||-NONE-|||1

