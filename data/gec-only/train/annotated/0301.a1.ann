Про анотації типів у Python
Колись Python був доволі вдало {спроектованою=>спроєктованою:::error_type=Spelling} мовою{=>,:::error_type=Punctuation} і я {з=>із:::error_type=Spelling} задоволенням на ньому писав. Потім, десь починаючи з Python 2.5, мова почала скурвлюватися. Зрештою, я майже перестав її використовувати: змінився і характер розробок, і кращі альтернативи. Але краєм ока я за ним спостерігаю і навіть, інколи, щось пописую. Ось недавно у мене і стався маленький {проект=>проєкт:::error_type=Spelling} під Raspberry Pi і Python там виявився доцільним. Заодно, я краєм ока глянув на анотацію типів. І побачив шизофренію{:=>.:::error_type=Punctuation}
А тепер детально, що не так. Python являється{  => :::error_type=Punctuation}мовою з динамічною типізацією. Якщо ви пишете скрипт{,=>:::error_type=Punctuation} чи користуєтесь техніками на кшталт DDD, то це в тему. Але тут є і два основні недоліки: динаміка дорога в плані швидкодії і, що набагато гірше, неочевидна для програміста. Поки це невеликий скрипт, це не є проблемою, програміст тримає в голові те, що він передає та хоче отримати, але вже на кількох тисячах рядків або командній роботі це починає давати збої{=>,:::error_type=Punctuation} і потрібна інформація про типи{,=>:::error_type=Punctuation} як окремий випадок так званих “контрактів”. Наприклад, “я передаю число {і=>й:::error_type=Spelling} очікую, що мені повернуть нове число”. Зазвичай контракти реалізуються на основі статичної типізації, коли вказується тип параметрів і значення, {що=>яке:::error_type=G/Conjunction} повертається. Це я і спробував зробити у typed_twice(). У мовах типу Lisp, SmallTalk чи Erlang програміст працює з так званим о́бразом програми і його текстовий редактор бере звідти дані про типи, структуру, зміни в ній, тощо. Оскільки Python є скриптовою мовою, він не створює такого {о́браза=>о́бразу:::error_type=G/Case}, а кожного разу читає, а потім виконує код програми. Отже, йому нема звідки знати, які типи використовуються, тому залишається тільки статичний аналіз. Але Python — мова з динамічною типізацією. Так от, анотації типів і є спробою ввести статику, але не скасовувати динаміку. Я спочатку подумав, що я чогось не розумію, тому звернувся до документації:
Це виявилося спробою всидіти на двох стільцях. Тобто вони, в МІНОРНІЙ гілці, поламали сумісність{=>(:::error_type=Punctuation}!{=>):::error_type=Punctuation} і свідомо пішли на порушення контракту просто заради того, щоб ДОПОМОГТИ ТЕКСТОВОМУ РЕДАКТОРУ! Це те саме, що штовхати справну автівку, щоб їй було легше! Казкові, просто казкові люди!
З іншої сторони, якщо ти розумієш необхідність статичної типізації, краще взяти щось статичне, наприклад{=>,:::error_type=Punctuation} Java, C#, Go чи Swift, а не цю пародію на Java. Тим більше, що у Java завезли приємне виведення типів.
А якщо дуже хочеться, то це все можна було зробити, не засмічуючи мову{,=>:::error_type=Punctuation} і не ламаючи сумісність на декораторах, десь так{:=>.:::error_type=Punctuation}
